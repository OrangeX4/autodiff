<style>
h1 {
    text-align: center;
}
h2, h3 {
    page-break-after: avoid; 
}
.center {
    margin: 0 auto;
    width: fit-content;
    margin-top: 2em;
    padding-top: 0.5em;
    padding-bottom: 0.5em;
    margin-bottom: 2em;
}
.title {
    font-weight: bold;
    border-top-style: solid;
    border-bottom-style: solid;
}
.newpage {
    page-break-after: always
}
@media print {
    @page {
        margin: 3cm;
    }
}
</style>

<h1 style="margin-top: 4em">
软件工程实验报告
</h1>

# <h1 class="center title">实验四：等价判断</h1>

<div class="center">
<h3>院系：人工智能学院</h3>
<h3>姓名：方盛俊</h3>
<h3>学号：201300035</h3>
<h3>班级：人工智能 20 级 2 班</h3>
<h3>邮箱：201300035@smail.nju.edu.cn</h3>
<h3>时间：2022 年 10 月 31 日</h3>
</div>

<div class="newpage"></div>

<!-- 生成目录 -->

## <h1>目录</h1>

[TOC]

<div class="newpage"></div>

<!-- 文章主体内容 -->

## 一、版本控制

在进行版本控制之前，先按照上一次实验书写的实验报告，初始化好项目结构：

```txt
.
│  .gitignore  (不加入 Git 里的文件)
│  lab4-report-201300035.md  (实验报告)
│  main.py  (项目主入口)
│  requirements.txt  (Python 依赖文件)
├─cluster
├─data  (示例数据)
│  ├─input
│  │  ├─4A
│  │  │      101036360.cpp
│  │  │      117364748.cpp
│  │  │      127473352.cpp
│  │  │      134841308.cpp
│  │  │      173077807.cpp
│  │  │      48762087.cpp
│  │  │      84822638.cpp
│  │  │      84822639.cpp
│  │  │      stdin_format.txt
│  │  └─50A
│  │          138805414.cpp
│  │          142890373.cpp
│  │          164831265.cpp
│  │          21508887.cpp
│  │          21508898.cpp
│  │          21715601.cpp
│  │          29019948.cpp
│  │          30534178.cpp
│  │          31034693.cpp
│  │          33794240.cpp
│  │          36641065.cpp
│  │          45851050.cpp
│  │          stdin_format.txt
│  └─output
├─diff
├─generator
├─images
├─input
├─output
├─paracomp
└─server
```

### 1. Git Init

执行 `git init` 初始化项目的 Git 仓库。

![](images/2022-10-31-22-01-20.png)

![](images/2022-10-31-22-02-13.png)

可见 VS Code 版本控制面板和目录树标绿，说明已经初始化完毕，正在等待将文件加入 Git 仓库中。

### 2. 编写 `.gitignore` 文件

编写 `.gitignore` 文件，将无需加入 Git 仓库的文件标在这里。

```gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Executables
*.exe
*.out

# IDE/Editor configuration
.vscode/

# Filesystem file
.DS_Store
```

这是很重要的一步，可以避免无用文件被加入 Git 仓库里 (例如一些需要实时生成的二进制文件和可执行文件，以及与 IDE 紧耦合的配置文件)。

### 3. Git Add

执行 `git add *` 将所有文件加入到 Git 仓库中。

![](images/2022-10-31-22-17-40.png)

执行前的 `git status`：

![](images/2022-10-31-22-24-37.png)

执行后的 `git status`：

![](images/2022-10-31-22-25-10.png)

### 4. Git Commit

执行 `git commit -m "feat: init"` 进行一次初始化的 Commit，并附上 Commit 信息 `feat: init`。

![](images/2022-10-31-22-21-07.png)

执行前的 `git status`：

![](images/2022-10-31-22-25-10.png)

执行后的 `git status`：

![](images/2022-10-31-22-26-22.png)

### 5. Git Diff

`main.py` 的内容原本为：

```python
print('Hello World')
```

为了进行一次 Commit，我们将其修改为：

```python
print('Hello World')
print('Hello Software Engineering')
```

执行 `git add *` 后执行 `git commit -m "feat: change main.py"`，将变动 Commit 到 Git 仓库中。

执行 `git diff` 我们可以发现我们的更改切实地被加入到了 Git 仓库中。

![](images/2022-10-31-22-42-13.png)

### 6. Git Reset

Git Reset 命令用于重置当前 HEAD 到指定的版本。

执行 `git log` 我们可以看出我们当前有 `feat: init` 和 `feat: change main.py` 这两条 Commit。

![](images/2022-10-31-22-44-09.png)

执行 `git reset 1ad1f9` 我们就可以恢复到 `feat: init` 这一条 Commit 所在的位置。

![](images/2022-10-31-22-48-51.png)

执行 `git log`，我们发现我们确实已经回到了只有一条 Commit 的状态。

![](images/2022-10-31-22-49-43.png)

### 7. Git Revert

使用 Git Revert 命令和 Git Reset 很类似，均是要恢复到之前的某些版本，但是 Git Revert 的好处在于，会把之前的 commit history 给保留下来，并把这次撤销作为一个新的 Commit。

执行 `git reset 1409930` 来恢复 `feat: change main.py` 这条 Commit，并执行 `git log` 显示：

![](images/2022-10-31-23-09-57.png)

执行 `git revert HEAD`，我们就能撤销当前版本的修改，恢复上一个版本，并在不改变 commit history 的情况下，创建一个新的 Commit。

![](images/2022-10-31-23-23-14.png)

我们可以看出，`main.py` 文件的内容也成功回退到上一个版本了。

执行 `git log` 我们可以更清晰地看出我们做的操作：

![](images/2022-10-31-23-24-34.png)

再次执行 `git revert HEAD`，我们可以发现 `main.py` 又恢复到了最新版本，这大概就是 `git revert` 操作的“负负得正”。

![](images/2022-10-31-23-26-13.png)

### 8. Git Stash

> 有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 `git stash` 命令。

这是 Git 官方文档对 Git Stash 命令的解释。事实上我也确实用到了这个命令。

在上一小节的 Git Revert 命令演示中，由于我是在同步编写实验报告，所以工作区实际上有一些变动，这导致我无法正常 `git revert`。

![](images/2022-10-31-23-29-14.png)

这种时候，我就可以执行 `git stash`，将我对实验报告的修改暂存了起来，这样工作区就又恢复了干净的状态，同时我们可以用 `git stash list` 查看我们放在栈上的暂存修改。

![](images/2022-10-31-23-30-50.png)

在我们做完了其他工作，想要恢复暂存的修改的时候，就可以执行 `git stash apply` 将修改恢复过来了。

![](images/2022-10-31-23-32-34.png)

### 8. Git Checkout

执行 `git checkout -b dev` 创建 `dev` 分支，并使用 `git branch` 查看。

![](images/2022-10-31-23-48-30.png)

使用 `git checkout master` 和 `git checkout dev` 可以切换分支。

![](images/2022-10-31-23-49-33.png)

### 9. Git Merge

我们修改 `main.py` 的内容为，并 Commit 到 `dev` 分支上：

```python
print('Hello World')
print('Hello Software Engineering')
print('New Branch')
```

![](images/2022-10-31-23-52-01.png)

我们执行 `git checkout master` 后执行 `git merge dev` 进行合并。

![](images/2022-10-31-23-55-06.png)

执行 `git log --graph --decorate --oneline --all` 可以看出中途 `dev` 分支被分离了出去，进行了一次 Commit 之后才被合并的。

![](images/2022-10-31-23-58-40.png)

### 10. Git Rebase

除了 Git Merge 命令之外，还有一种可以对分支进行合并的命令，即 Git Rebase 命令。

要理解 Git Rebase 命令其实很简单，我们知道每个版本其实保存了一个类似于父节点的指针，通过父节点指针我们就可以从 HEAD 一路找到初始化版本，并通过 Git Log 显示出来。理论上来说这个父节点指针不应该由我们控制，应该由 Git 自己管理，但是执行 Git Rebase 操作可以让我们更改分支的父节点指针，让当前分支的父节点指向另一个分支的最新节点，也就是“变基”操作。

我们先在 master 分支对 `main.py` 进行一点修改：

```python
print('Hello World')
print('Hello Software Engineering')
print('New Branch')
print('Change For Branch Master')
```

然后执行 `git add *` 和 `git commit -m "fix: change for branch master"` 进行 Commit。

执行 `git checkout dev` 切换到 `dev` 分支，并且同样在 master 分支对 `main.py` 进行一点修改：

```python
print('Hello World')
print('Hello Software Engineering')
print('New Branch')
print('Change For Branch Dev')
```

然后执行 `git add *` 和 `git commit -m "fix: change for branch dev"` 进行 Commit。

此时我们执行 `git log --graph --decorate --oneline --all` 看一下情况：

![](images/2022-11-01-10-33-28.png)

最关键的一步来了，我们执行 `git rebase master` 进行变基，将 dev 的父节点设为 master 的最新节点。

![](images/2022-11-01-10-39-34.png)

我们再次执行 `git log --graph --decorate --oneline --all` 看一下情况：

![](images/2022-11-01-10-45-25.png)

最后我们执行 `git checkout master` 和 `git merge dev` 让 master 分支行进到最新的节点。

![](images/2022-11-01-10-46-31.png)

### 11. Git Cherry Pick

> 对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。
> 这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry Pick。

因此我们可以知道，Git Cherry Pick 命令很类似 Git Merge 命令，只不过可以选择合并某个 Commit 而不是合并某个分支。

我们执行 `git checkout dev` 切换到 dev 分支后，添加两个 Commit。

可以看出，我们当前有两个新的 Commit：`feat: change 1` 和 `feat: change 2`。

![](images/2022-11-01-10-57-45.png)

我们执行 `git checkout master` 切换到 master 分支后，然后执行 `git cherry-pick 40fad27` 只合并 dev 分支的 `feat: change 1`。

![](images/2022-11-01-11-01-25.png)

可以看到，我们的 master 分支确实合并了 `feat: change 1` Commit。

### 12. GitHub 远程仓库

我们先在 GitHub 上创建一个新的 Repo。

![](images/2022-11-01-11-11-37.png)

执行

```sh
git remote add origin https://github.com/OrangeX4/autodiff.git
git push -u origin master
git push origin dev
```

将所有分支推送上去。

![](images/2022-11-01-11-14-04.png)

可以看见在地址 https://github.com/OrangeX4/autodiff/tree/master 已经成功推送了上去。

![](images/2022-11-01-11-15-17.png)